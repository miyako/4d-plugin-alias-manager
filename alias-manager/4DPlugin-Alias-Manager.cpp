/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Alias-Manager.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Alias Manager
 #	author : miyako
 #	2019/10/14
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Alias-Manager.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- Alias Manager
            
			case 1 :
				ALIAS_Create(params);
				break;
			case 2 :
				ALIAS_Resolve(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void ALIAS_Create(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT Param3;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    NSFileManager *defaultFileManager = [NSFileManager defaultManager];
    
    NSURL *srcUrl = Param1.copyUrl();
    if(srcUrl){
        NSURL *dstUrl = Param2.copyUrl();
        if(dstUrl){
            
            switch(Param3.getIntValue()){
                case LinkSymbolic:
                    returnValue.setIntValue([defaultFileManager createSymbolicLinkAtURL:dstUrl withDestinationURL:srcUrl error:nil]);
                    break;
                case LinkHard:
                    returnValue.setIntValue([defaultFileManager linkItemAtURL:srcUrl toURL:dstUrl error:nil]);
                    break;
                case LinkAlias:
                    NSData *bookmark = [srcUrl
                                        bookmarkDataWithOptions:NSURLBookmarkCreationSuitableForBookmarkFile
                                        includingResourceValuesForKeys:[NSArray array]
                                        relativeToURL:nil
                                        error:nil];
                    
                    if(bookmark){
                        
                        returnValue.setIntValue([NSURL
                                                 writeBookmarkData:bookmark
                                                 toURL:dstUrl
                                                 options:NSURLBookmarkCreationSuitableForBookmarkFile
                                                 error:nil]);
                    }
                    
                    break;
                    
            }
            [dstUrl release];
        }
        
        [srcUrl release];
    }
    
    returnValue.setReturn(pResult);
}

void ALIAS_Resolve(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_LONGINT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.setIntValue(-1);
    
    NSFileManager *defaultFileManager = [NSFileManager defaultManager];
    
    NSString *path = Param1.copyPath();
    
    if(path)
    {
        NSDictionary *dict = [defaultFileManager attributesOfItemAtPath:path error:NULL];
        
        if(dict)
        {
            
            if([[dict objectForKey:NSFileType]isEqualToString:NSFileTypeSymbolicLink])
            {
                NSString *resolved_path = [defaultFileManager
                                           destinationOfSymbolicLinkAtPath:path
                                           error:NULL];
                
                if(resolved_path)
                {
                    //is symbolic link
                    Param2.setIntValue(LinkSymbolic);
                    returnValue.setPath(resolved_path);
                }
            }else
            {
                NSURL *url = Param1.copyUrl();
                
                if(url)
                {
                    NSData *bookmark = [NSURL bookmarkDataWithContentsOfURL:url error:NULL];
                    
                    if(bookmark)
                    {
                        BOOL isStale = YES;
                        
                        NSURL *resolved_url = [[NSURL alloc]
                                               initByResolvingBookmarkData:bookmark
                                               options:NSURLBookmarkResolutionWithoutUI
                                               relativeToURL:NULL
                                               bookmarkDataIsStale:&isStale
                                               error:NULL];
                        
                        if(resolved_url)
                        {
                            if (![resolved_url isEqual:url])
                            {
                                //is alias
                                Param2.setIntValue(LinkAlias);
                                NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)resolved_url, kCFURLHFSPathStyle);
                                returnValue.setUTF16String(path);
                                [path release];
                            }
                            [resolved_url release];
                        }
                        
                    }else
                    {
                        //maybe hardlink
                        UInt32 fileID;
                        FSVolumeRefNum volumeID;
                        int err = pathGetFSRefID(path, &volumeID, &fileID);
                        if(!err)
                        {
                            if(!pathResolveFSRefID(volumeID, fileID, returnValue))
                            {
                                Param2.setIntValue(LinkHard);
                            }
                        }
                    }
                    [url release];
                }
                
            }
            
        }
        
        [path release];
    }
    
    Param2.toParamAtIndex(pParams, 2);
    returnValue.setReturn(pResult);
}

int pathGetFSRefID(NSString *path, FSVolumeRefNum *volumeID, UInt32 *fileID) {
    
    int err = -1;
    
    FSRef fSRef;
    NSURL *url = [[NSURL alloc]initFileURLWithPath:path];
    if(url)
    {
        if(CFURLGetFSRef((CFURLRef)url, &fSRef))
        {
            FSCatalogInfo catalogInfo;
            err = FSGetCatalogInfo(&fSRef,
                                   kFSCatInfoNodeID|kFSCatInfoVolume,
                                   &catalogInfo,
                                   NULL, NULL, NULL);
            if(err == noErr)
            {
                *volumeID = catalogInfo.volume;
                *fileID = catalogInfo.nodeID;
                err = 0;
            }
        }
        [url release];
    }
    
    return err;
}

int pathResolveFSRefID(FSVolumeRefNum volumeID, UInt32 fileID, C_TEXT &path) {
    
    int err = -1;
    
    FSRef fSRef;
    if(!FSResolveNodeID(volumeID, fileID, &fSRef))
    {
        NSURL *url = (NSURL *)CFURLCreateFromFSRef(kCFAllocatorDefault, &fSRef);
        if(url)
        {
            NSString *_path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLHFSPathStyle);
            path.setUTF16String(_path);
            [_path release];
            err = 0;
        }
    }
    
    return err;
}
